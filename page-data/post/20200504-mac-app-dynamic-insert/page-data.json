{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/20200504-mac-app-dynamic-insert/","result":{"data":{"site":{"siteMetadata":{"title":"lqqyt2423's blog"}},"markdownRemark":{"id":"67e1444e-cf5b-5302-8d30-d2ab8e1e2f8f","excerpt":"跑通了一个最简单的动态注入的 demo，记录一下以防忘记。 原理相关 在 Mac 上，应用最终会 build 成可执行的二进制文件，而逆向就是为了改变应用原本的功能。这里实现的一种方法是：通过编写动态链接库将额外逻辑注入到应用中。\n本文用到了 insert_dylib 注入工具： Command line…","html":"<p>跑通了一个最简单的动态注入的 demo，记录一下以防忘记。</p>\n<h3>原理相关</h3>\n<p>在 Mac 上，应用最终会 build 成可执行的二进制文件，而逆向就是为了改变应用原本的功能。这里实现的一种方法是：通过编写动态链接库将额外逻辑注入到应用中。\n本文用到了 <a href=\"https://github.com/Tyilo/insert_dylib\">insert_dylib</a> 注入工具：</p>\n<blockquote>\n<p>Command line utility for inserting a dylib load command into a Mach-O binary.</p>\n</blockquote>\n<p>这个工具应该是可以直接修改应用二进制文件，使应用加载时加载自己编写的动态库。</p>\n<blockquote>\n<p>Objective-C的首选hook方案为Method Swizzle。</p>\n</blockquote>\n<h3>步骤</h3>\n<h4>先用 objective-c 实现一个最简单的应用</h4>\n<p><code class=\"language-text\">Person.h</code></p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">#import &lt;Foundation/Foundation.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface Person : NSObject\n\n@property (nonatomic) NSString *name;\n@property (nonatomic) NSNumber *age;\n\n@end\n\nNS_ASSUME_NONNULL_END</code></pre></div>\n<p><code class=\"language-text\">Person.m</code></p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">#import &quot;Person.h&quot;\n\n@implementation Person\n\n- (NSString *)description\n{\n    return [NSString stringWithFormat:@&quot;&lt;%@: %@&gt;&quot;, self.name, self.age];\n}\n\n@end</code></pre></div>\n<p><code class=\"language-text\">main.m</code></p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">#import &lt;Foundation/Foundation.h&gt;\n#import &quot;Person.h&quot;\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@&quot;hello liqiang&quot;);\n        \n        Person *p = [[Person alloc] init];\n        [p setName:@&quot;liqiang&quot;];\n        [p setAge:@26];\n        \n        NSLog(@&quot;person: %@&quot;, p);\n    }\n    return 0;\n}</code></pre></div>\n<p>编译执行后会输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2020-05-04 17:09:19.146 hello[45102:759505] hello liqiang\n2020-05-04 17:09:19.147 hello[45102:759505] person: &lt;liqiang: 26&gt;</code></pre></div>\n<h4>hook 项目</h4>\n<p>新建 <code class=\"language-text\">Library</code> 类型的项目。下面的 <code class=\"language-text\">hookCommon</code> 相关代码实现的功能是替换应用中对应的方法为自己编写的方法，应该是 <code class=\"language-text\">Method Swizzl</code>。</p>\n<p><code class=\"language-text\">hookCommon.h</code></p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">#import &lt;Foundation/Foundation.h&gt;\n#import &lt;objc/runtime.h&gt;\n\n@interface hookCommon : NSObject\n\n/**\n 替换对象方法\n\n @param originalClass 原始类\n @param originalSelector 原始类的方法\n @param swizzledClass 替换类\n @param swizzledSelector 替换类的方法\n */\nvoid hookMethod(Class originalClass, SEL originalSelector, Class swizzledClass, SEL swizzledSelector);\n\n/**\n 替换类方法\n \n @param originalClass 原始类\n @param originalSelector 原始类的类方法\n @param swizzledClass 替换类\n @param swizzledSelector 替换类的类方法\n */\nvoid hookClassMethod(Class originalClass, SEL originalSelector, Class swizzledClass, SEL swizzledSelector);\n\n@end</code></pre></div>\n<p><code class=\"language-text\">hookCommon.m</code></p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">#import &quot;hookCommon.h&quot;\n\n@implementation hookCommon\n\n/**\n 替换对象方法\n \n @param originalClass 原始类\n @param originalSelector 原始类的方法\n @param swizzledClass 替换类\n @param swizzledSelector 替换类的方法\n */\nvoid hookMethod(Class originalClass, SEL originalSelector, Class swizzledClass, SEL swizzledSelector) {\n    Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);\n    if (originalMethod &amp;&amp; swizzledMethod) {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n/**\n 替换类方法\n \n @param originalClass 原始类\n @param originalSelector 原始类的类方法\n @param swizzledClass 替换类\n @param swizzledSelector 替换类的类方法\n */\nvoid hookClassMethod(Class originalClass, SEL originalSelector, Class swizzledClass, SEL swizzledSelector) {\n    Method originalMethod = class_getClassMethod(originalClass, originalSelector);\n    Method swizzledMethod = class_getClassMethod(swizzledClass, swizzledSelector);\n    if (originalMethod &amp;&amp; swizzledMethod) {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n@end</code></pre></div>\n<p>然后替换掉 <code class=\"language-text\">Person</code> 类中的 <code class=\"language-text\">description</code> 方法，功能是调用原逻辑前先打印一行自己的逻辑代码。</p>\n<p><code class=\"language-text\">Person_hook.h</code></p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">#import &lt;Foundation/Foundation.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface NSObject (PersonHook)\n\n+ (void) hookPerson;\n\n@end\n\nNS_ASSUME_NONNULL_END</code></pre></div>\n<p><code class=\"language-text\">Person_hook.m</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#import &quot;Person_hook.h&quot;\n#import &quot;hookCommon.h&quot;\n\n@implementation NSObject (PersonHook)\n\n// hook person description\n- (NSString *) personDescription\n{\n    NSLog(@&quot;in personDescription&quot;);\n    return [self personDescription];\n}\n\n+ (void) hookPerson\n{\n    NSLog(@&quot;in hookPerson&quot;);\n    hookMethod(objc_getClass(&quot;Person&quot;), @selector(description), [self class], @selector(personDescription));\n}\n\n@end</code></pre></div>\n<p><code class=\"language-text\">main.m</code></p>\n<div class=\"gatsby-highlight\" data-language=\"objective-c\"><pre class=\"language-objective-c\"><code class=\"language-objective-c\">#import &lt;Foundation/Foundation.h&gt;\n#import &quot;Person_hook.h&quot;\n\nstatic void __attribute__((constructor)) initialize(void) {\n    NSLog(@&quot;hook common inject success!&quot;);\n    \n    [NSObject hookPerson];\n}</code></pre></div>\n<p><code class=\"language-text\">__attribute__((constructor))</code> 修饰函数之后，便会在应用加载前执行，也就是相当于我们注入代码的逻辑入口。上面逻辑中会用方法 <code class=\"language-text\">personDescription</code> 替换 <code class=\"language-text\">Person</code> 类中的 <code class=\"language-text\">description</code> 方法，注意此方法中会调用自己，其实不会造成死循环，因为运行时两个方法已经交换了，所以是调用的原始逻辑。</p>\n<h4>实验</h4>\n<p>将上面 hook 项目 build 之后，得到 <code class=\"language-text\">libhookCommon.dylib</code>，然后将此动态库和第一步应用二进制文件 <code class=\"language-text\">hello</code> 放在同一目录，加上用到 <code class=\"language-text\">insert_dylib</code> 注入工具，然后执行注入命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./insert_dylib libhookCommon.dylib hello</code></pre></div>\n<p>生成 <code class=\"language-text\">hello_patched</code> 程序，运行此程序：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./hello_patched</code></pre></div>\n<p>得到的输出为：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2020-05-04 17:23:18.461 hello_patched[45156:766500] hook common inject success!\n2020-05-04 17:23:18.461 hello_patched[45156:766500] in hookPerson\n2020-05-04 17:23:18.461 hello_patched[45156:766500] hello liqiang\n2020-05-04 17:23:18.461 hello_patched[45156:766500] in personDescription\n2020-05-04 17:23:18.462 hello_patched[45156:766500] in personDescription\n2020-05-04 17:23:18.462 hello_patched[45156:766500] person: &lt;liqiang: 26&gt;</code></pre></div>\n<p>通过输出可以看出已经加入了自己的逻辑进来了。</p>\n<h3>思考</h3>\n<p>一般要想修改某个应用的逻辑功能，肯定是拿不到源代码的，所以通过二进制代码理解程序逻辑这一步，才是难点中的难点。必须要了解汇编，一些逆向的工具，还需要经验等等。而本文也仅是作为新手的我所能了解到的一些皮毛而已。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://book.douban.com/subject/19962787/\">Objective-C编程</a></li>\n<li><a href=\"https://blog.nswebfrog.com/2018/02/09/make-injection-app-for-mac/\">macOS 逆向之生成动态注入 App</a></li>\n<li><a href=\"https://www.jianshu.com/p/d7a0ccc6a7e6\">动态注入 dylib到 Mac 应用</a></li>\n<li><a href=\"https://github.com/Tyilo/insert_dylib\">insert_dylib</a></li>\n<li><a href=\"https://www.jianshu.com/p/c04ac36c6641\">最简单的Hopper Disassembler玩转Mac逆向</a></li>\n<li><a href=\"http://yunlaiwu.github.io/blog/2017/05/22/ios%E4%BB%8Ehook%E5%88%B0methodSwizzling/\">从hook到IOS黑魔法－Method Swizzling</a></li>\n<li><a href=\"https://blog.sunnyyoung.net/wei-xin-macos-ke-hu-duan-lan-jie-che-hui-gong-neng-shi-jian/\">微信 macOS 客户端拦截撤回功能实践</a></li>\n</ul>","frontmatter":{"title":"mac app 逆向之动态注入","date":"May 03, 2020","description":""}}},"pageContext":{"slug":"/20200504-mac-app-dynamic-insert/","previous":{"fields":{"slug":"/20200414-openssl-create-cert/","path":"/post/20200414-openssl-create-cert/"},"frontmatter":{"title":"openssl 生成证书的操作"}},"next":null}}}