{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/20180320-knowledge-of-linux/","result":{"data":{"site":{"siteMetadata":{"title":"lqqyt2423's blog"}},"markdownRemark":{"id":"cdf129ef-ce66-52b8-a2da-5baf91b1a4b5","excerpt":"文档/帮助相关 man 页面中标题旁代号的意思 1 使用者在shell环境中可以操作的命令或可运行文件 2 系统核心可呼叫的函数与工具等 3 一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc) 4 装置文件的说明，通常在/dev下的文件 5 配置文件或者是某些文件的格式…","html":"<h2>文档/帮助相关</h2>\n<p>man 页面中标题旁代号的意思</p>\n<ul>\n<li>1 使用者在shell环境中可以操作的命令或可运行文件</li>\n<li>2 系统核心可呼叫的函数与工具等</li>\n<li>3 一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc)</li>\n<li>4 装置文件的说明，通常在/dev下的文件</li>\n<li>5 配置文件或者是某些文件的格式</li>\n<li>6 游戏(games)</li>\n<li>7 惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明</li>\n<li>8 系统管理员可用的管理命令</li>\n<li>9 跟kernel有关的文件</li>\n</ul>\n<p>man 页面各个分级内容的意思</p>\n<ul>\n<li>NAME  简短的命令、数据名称说明</li>\n<li>SYNOPSIS  简短的命令下达语法(syntax)简介</li>\n<li>DESCRIPTION 较为完整的说明，这部分最好仔细看看！</li>\n<li>OPTIONS 针对 SYNOPSIS 部分中，有列举的所有可用的选项说明</li>\n<li>COMMANDS  当这个程序(软件)在运行的时候，可以在此程序(软件)中下达的命令</li>\n<li>FILES 这个程序或数据所使用或参考或连结到的某些文件</li>\n<li>SEE ALSO  可以参考的，跟这个命令或数据有相关的其他说明！</li>\n<li>EXAMPLE 一些可以参考的范例</li>\n<li>BUGS  是否有相关的臭虫！</li>\n</ul>\n<p>放文档的地址：<code class=\"language-text\">/usr/share/doc</code></p>\n<h2>检查Linux 状态时有用的命令</h2>\n<p>如果要看目前有谁在在线，可以下达『who』这个命令\n如果要看网络的联机状态，可以下达 『 netstat -a 』这个命令\n要看背景运行的程序可以运行『 ps -aux 』这个命令。</p>\n<h2>Linux系统里面账号、密码、群组信息的保存位置</h2>\n<p>所有的系统上的账号与一般身份使用者，还有那个root的相关信息， 都是记录在/etc/passwd这个文件内的\n个人的密码则是记录在/etc/shadow这个文件下\n所有的组名都纪录在/etc/group内</p>\n<h2>修改文件属性与权限</h2>\n<ul>\n<li>chgrp: 改变文件所属群组 --- 要被改变的组名必须要在/etc/group 文件内存在才行</li>\n<li>chown: 改变文件拥有者 --- 在/etc/passwd 这个文件中有纪录的用户名称才能改变</li>\n<li>chmod: 改变文件的权限, SUID, SGID, SBIT 等等的特性</li>\n</ul>\n<h2>Filesystem Hierarchy Standard (FHS)</h2>\n<ul>\n<li>/bin 系统有很多放置执行文件的目录，但/bin 比较特殊。因为/bin 放置的是在单人维护模式下还能够被操作的指令</li>\n<li>/boot 这个目录主要在放置开机会使用到的文件，包括 Linux 核心文件以及开机选单与开机所需配置文件等</li>\n<li>/dev 在 Linux 系统上，任何装置与接口设备都是以文件的型态存在于这个目录当中的</li>\n<li>/etc 系统主要的配置文件几乎都放置在这个目录内</li>\n<li>/lib 在开机时会用到的函式库， 以及在/bin 或/sbin 底下的指令 会呼叫的函式库而已</li>\n<li>/srv 可以视为『service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录</li>\n<li>/usr /usr 里面放置的数据属于可分享的与不可变动的，usr 是 Unix Software Resource 的缩写， 也就是『Unix 操 作系统软件资源』所放置的目录</li>\n<li>/var 主要针对常态性变动的文件，包括快取(cache)、登录档(log file)以及某些软件运 作所产生的文件</li>\n</ul>\n<h3>usr</h3>\n<ul>\n<li>/usr/bin 所有一般用户能够使用的指令都放在这里</li>\n<li>/usr/local 系统管理员在本机自行安装自己下载的软件(非 distribution 默认提供者)，建议安装到此目录， 这 样会比较便于管理</li>\n<li>/usr/share 主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件 架构均可读取的数据， 因为几乎都是文本文件</li>\n<li>/usr/src 一般原始码建议放置到这里，src 有 source 的意思。至于核心原始码则建议放置到/usr/src/linux/ 目录下</li>\n</ul>\n<h3>var</h3>\n<ul>\n<li>/var/cache 应用程序本身运作过程中会产生的一些暂存档</li>\n<li>/var/lib 程序本身执行的过程中，需要使用到的数据文件放置的目录</li>\n<li>/var/log 重要到不行!这是登录文件放置的目录!里面比较重要的文件如/var/log/messages, /var/log/wtmp(记 录登入者的信息)等</li>\n<li>/var/mail 放置个人电子邮件信箱的目录</li>\n<li>/var/run 某些程序或者是服务启动后，会将他们的 PID 放置在这个目录下</li>\n</ul>\n<h2>文件内容查阅</h2>\n<ul>\n<li>cat 由第一行开始显示文件内容</li>\n<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写</li>\n<li>nl 显示的时候，顺道输出行号 --- cat -n</li>\n<li>more 一页一页的显示文件内容</li>\n<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页</li>\n<li>head 只看头几行</li>\n<li>tail 只看尾巴几行</li>\n<li>od 以二进制的方式读取文件内容</li>\n</ul>\n<p>举例：显示10到20行的数据 <code class=\"language-text\">cat ./file.txt | head -n 20 | tail -n 10</code></p>\n<h2>文件系统的运作</h2>\n<p>文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。 另外，还有一个超级区块 (superblock) 会记 录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p>\n<p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p>\n<ul>\n<li>superblock 记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的 格式与相关信息等</li>\n<li>inode 记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码</li>\n<li>block 实际记录文件的内容，若文件太大时，会占用多个 block</li>\n</ul>\n<h3>inode 记录的文件数据</h3>\n<ul>\n<li>该文件的存取模式(read/write/excute)</li>\n<li>该文件的拥有者与群组(owner/group)</li>\n<li>该文件的容量</li>\n<li>该文件建立或状态改变的时间(ctime)</li>\n<li>最近一次的读取时间(atime)</li>\n<li>最近修改的时间(mtime)</li>\n<li>定义文件特性的旗标(flag)，如 SetUID…</li>\n<li>该文件真正内容的指向 (pointer)</li>\n</ul>\n<h2>压缩指令</h2>\n<h3>常见的压缩文件扩展名</h3>\n<ul>\n<li>*.Z compress 程序压缩的文件;</li>\n<li>*.zip zip 程序压缩的文件;</li>\n<li>*.gz gzip 程序压缩的文件;</li>\n<li>*.bz2 bzip2 程序压缩的文件;</li>\n<li>*.xz xz 程序压缩的文件;</li>\n<li>*.tar tar 程序打包的数据，并没有压缩过;</li>\n<li>*.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩</li>\n<li>*.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩</li>\n<li>*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩</li>\n</ul>\n<h3>常用压缩命令</h3>\n<ul>\n<li>压缩某文件，不保留源文件：<code class=\"language-text\">gzip 1.txt</code></li>\n<li>解压缩某文件，不保留源文件：<code class=\"language-text\">gzip -d 1.txt.gz</code></li>\n<li>压缩文件输出流，可重导向：<code class=\"language-text\">gzip -c 1.txt &gt; 1.txt.gz</code></li>\n<li><code class=\"language-text\">bzip2</code>和<code class=\"language-text\">xz</code>命令与上面3个相同，之后后缀改为<code class=\"language-text\">bz2</code></li>\n<li><code class=\"language-text\">bzip2</code>和<code class=\"language-text\">xz</code> 多了个<code class=\"language-text\">-k</code>的参数，保留源文件</li>\n</ul>\n<h3>打包指令tar</h3>\n<ul>\n<li>打包与压缩 <code class=\"language-text\">tar [-z|-j|-J] [cv] [-f 待建立的新檔名] filename...</code></li>\n<li>查看包含的文件名称 <code class=\"language-text\">tar [-z|-j|-J] [tv] [-f 既有的 tar 檔名]</code></li>\n<li>解压缩 <code class=\"language-text\">tar [-z|-j|-J] [xv] [-f 既有的 tar 檔名] [-C 目录]</code></li>\n</ul>\n<p><code class=\"language-text\">-z gzip | -j bzip2 | -J xz</code></p>\n<h2>bash</h2>\n<ul>\n<li>打印变量: <code class=\"language-text\">echo $PATH</code></li>\n<li>设置变量: <code class=\"language-text\">name=value</code></li>\n<li>可使用字符<code class=\"language-text\">\\</code> 将特殊字符变为一般字符</li>\n<li>若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容</li>\n<li>若该变量需要在其他子程序执行，则需要以 <code class=\"language-text\">export</code> 来使变量变成环境变量</li>\n<li>通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断</li>\n<li>取消变量的方法为使用 unset :『unset 变量名称』</li>\n<li><code class=\"language-text\">env</code>或 <code class=\"language-text\">export</code> 可列出环境变量</li>\n<li><code class=\"language-text\">set</code> 观察所有变量 (含环境变量与自定义变量)</li>\n<li>基本上，在 Linux 预设的情况中，使用{大写的字母}来设定的变量 一般为系统内定需要的变量</li>\n<li><code class=\"language-text\">export</code>: 自定义变量转成环境变量</li>\n<li><code class=\"language-text\">alias</code>: 设置别名</li>\n<li><code class=\"language-text\">unalias</code>: 取消别名</li>\n<li>bash 的进站与欢迎讯息: <code class=\"language-text\">/etc/issue, /etc/motd</code></li>\n<li><code class=\"language-text\">stty -a</code> 来列出目前环境中所有的按键列表</li>\n</ul>\n<p>设置变量时双引号和单引号的功能不同：</p>\n<ul>\n<li>双引号内的特殊字符如 $ 等，可以保有原本的特性</li>\n<li>单引号内的特殊字符则仅为一般字符 (纯文本)</li>\n</ul>\n<h3><code class=\"language-text\">stty</code> 列出的含义</h3>\n<ul>\n<li>intr : 送出一个 interrupt (中断) 的讯号给目前正在 run 的程序 (就是终止啰!);</li>\n<li>quit : 送出一个 quit 的讯号给目前正在 run 的程序;</li>\n<li>erase : 向后删除字符，</li>\n<li>kill : 删除在目前指令列上的所有文字;</li>\n<li>eof : End of file 的意思，代表『结束输入』。</li>\n<li>start : 在某个程序停止后，重新启动他的 output</li>\n<li>stop : 停止目前屏幕的输出;</li>\n<li>susp : 送出一个 terminal stop 的讯号给正在 run 的程序</li>\n</ul>\n<h3>快捷键对应的功能</h3>\n<ul>\n<li>CTRL + C: 终止目前的命令</li>\n<li>CTRL + D: 输入结束EOF</li>\n<li>CTRL + M: Enter</li>\n<li>CTRL + S: 暂停屏幕的输出</li>\n<li>CTRL + Q: 恢复屏幕的输出</li>\n<li>CTRL + U: 在提示字符下，将整列命令删除</li>\n<li>CTRL + Z: 『暂停』目前的命令</li>\n</ul>\n<h3>数据流重导向</h3>\n<p><code class=\"language-text\">&gt;</code> 为覆盖 <code class=\"language-text\">&gt;&gt;</code> 为累加</p>\n<ul>\n<li>标准输入 stdin 代码为0 使用<code class=\"language-text\">&lt;</code> 或<code class=\"language-text\">&lt;&lt;</code></li>\n<li>标准输出 stdout 代码为1 使用<code class=\"language-text\">&gt;</code> 或<code class=\"language-text\">&gt;&gt;</code></li>\n<li>标准错误输出 stderr 代码为2 使用<code class=\"language-text\">2&gt;</code> 或<code class=\"language-text\">2&gt;&gt;</code></li>\n</ul>\n<p>举例：</p>\n<p>将标准输出和标准错误输出分别保存至两个文件中：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> /home -name .bashrc <span class=\"token operator\">></span> list_right <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> list_error</code></pre></div>\n<p>不显示标准错误输出（导入到<code class=\"language-text\">/dev/null</code> 中）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> /home -name .bashrc <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> /dev/null</code></pre></div>\n<p>不区分标准输出和错误，一起导入到一个文件中：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> /home -name .bashrc <span class=\"token operator\">></span> list <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span></code></pre></div>\n<h2>账号管理、权限设置</h2>\n<p>命令相关：</p>\n<ul>\n<li>新增使用者：<code class=\"language-text\">useradd</code></li>\n<li>设置账号密码：<code class=\"language-text\">passwd</code></li>\n<li>更新使用者配置：<code class=\"language-text\">usermod</code></li>\n<li>删除y用户相关数据：<code class=\"language-text\">userdel</code></li>\n<li>查询uid/gid等信息：<code class=\"language-text\">id</code></li>\n<li>change shell： <code class=\"language-text\">chsh</code></li>\n<li>添加群组：<code class=\"language-text\">groupadd</code></li>\n<li>修改群组配置：<code class=\"language-text\">groupmod</code></li>\n<li>删除群组：<code class=\"language-text\">groupdel</code></li>\n<li>群组管理员功能：<code class=\"language-text\">gpasswd</code></li>\n<li>使用者身份切换：<code class=\"language-text\">su</code>, <code class=\"language-text\">sudo</code></li>\n<li>查询使用者：<code class=\"language-text\">w</code>, <code class=\"language-text\">who</code>, <code class=\"language-text\">last</code>, <code class=\"language-text\">lastlog</code></li>\n<li>邮件：<code class=\"language-text\">mail</code></li>\n</ul>\n<h2>例行性工作进程</h2>\n<p>无论是<code class=\"language-text\">at</code> 还是<code class=\"language-text\">crontab</code>，它们的最小时间单位都是<strong>分钟</strong>，在<strong>整分钟时间</strong>运行，即秒为0的时候运行。</p>\n<h3>仅执行一次的工作排程 at</h3>\n<p>必须有<code class=\"language-text\">atd</code> 进程运行，才会执行<code class=\"language-text\">at</code> 中设定的工作。用<code class=\"language-text\">at</code> 添加工作进程后，实际上是将此工作以文本方式写入至目录<code class=\"language-text\">/var/spool/at/</code> 中，然后该工作便能等待<code class=\"language-text\">atd</code> 的取用和执行了。</p>\n<p>可以使用<code class=\"language-text\">/etc/at.allow</code> 和<code class=\"language-text\">/etc/at.deny</code> 两个文件对使用<code class=\"language-text\">at</code> 命令的用户作出限制。</p>\n<p>命令</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">at <span class=\"token punctuation\">[</span>-mldv<span class=\"token punctuation\">]</span> TIME</code></pre></div>\n<ul>\n<li><code class=\"language-text\">-c</code>，列出某一项排程内容</li>\n<li><code class=\"language-text\">-l</code> 相当于<code class=\"language-text\">atq</code>，列出排程</li>\n<li><code class=\"language-text\">-d</code> 相当于<code class=\"language-text\">atrm</code>，删除某一排程</li>\n</ul>\n<p>TIME 的设定规则举例：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">at 04:00\nat 04:00 <span class=\"token number\">2018</span>-05-05\nat now + <span class=\"token number\">3</span> days\nat now + <span class=\"token number\">1</span> minute</code></pre></div>\n<ul>\n<li><code class=\"language-text\">at</code> 排程执行时是用的下达命令时所在的目录，所以为避免出错，目录相关设置可设置为绝对目录。</li>\n<li><code class=\"language-text\">at</code> 是背景执行的，类似于<code class=\"language-text\">nohup</code></li>\n</ul>\n<h3>系统有空时才进行的背景任务 batch</h3>\n<p>会在CPU负载小于0.8时，才进行所下达的任务。</p>\n<blockquote>\n<p>负载：CPU在单一时间点所负责的工作数量，而非CPU使用率。CPU负载越大，会频繁地在不同任务之间切换。命令<code class=\"language-text\">uptime</code> 可看到负载信息。</p>\n</blockquote>\n<p><code class=\"language-text\">batch</code> 也是用<code class=\"language-text\">atq/atrm</code> 来管理的。</p>\n<h3>循环执行的例行性工作排程</h3>\n<p>循环执行的例行性工作排程则是由<code class=\"language-text\">cron(crond)</code> 这个系统服务来控制的。</p>\n<p>可以使用<code class=\"language-text\">/etc/cron.allow</code> 和<code class=\"language-text\">/etc/cron.deny</code> 两个文件对使用<code class=\"language-text\">crontab</code> 命令的用户作出限制。</p>\n<p>当用户使用<code class=\"language-text\">crontab</code> 这个指令来建立工作排程之后，该项工作就会被纪录到<code class=\"language-text\">/var/spool/cron/</code> 里面去了，而且是以账号来作为判别的。</p>\n<p><code class=\"language-text\">crontab [-e][-l][-r]</code></p>\n<ul>\n<li><code class=\"language-text\">-e</code> 编辑工作内容</li>\n<li><code class=\"language-text\">-l</code> 查阅工作内容</li>\n<li><code class=\"language-text\">-r</code> 移除所有工作内容</li>\n</ul>\n<p>编辑工作内容，示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0-59 * * * * date &gt;&gt; 1.txt\n分 时 日 月 周 指令</code></pre></div>\n<p>特殊字符包括：星号*、逗号,、减号-、斜线/n</p>\n<p>命令内容建议使用<strong>绝对路径</strong>。</p>\n<p>如果是<strong>系统的例行性任务</strong>，可以直接编辑<code class=\"language-text\">/etc/crontab</code> 文件。</p>\n<p><code class=\"language-text\">crond</code> 预设有三个地方有会执行脚本配置文件：</p>\n<ul>\n<li><code class=\"language-text\">/etc/crontab</code> 系统维护管理</li>\n<li><code class=\"language-text\">/etc/cron.d/*</code> 自己开发软件</li>\n<li><code class=\"language-text\">/var/spool/cron/*</code> 个人行为</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">anacron</code> 可唤醒停机时间的工作任务</p>\n</blockquote>\n<h2>进程管理</h2>\n<p>程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载内存中，操作系统并给予这个内存内的单元一个标识符 (PID)，可以说，进程就是一个正在运作中的程序。</p>\n<p>子进程的PPID与父进程的PID相等。</p>\n<ul>\n<li><code class=\"language-text\">&amp;</code> 将工作丢到背景中执行</li>\n<li><code class=\"language-text\">ctrl + z</code> 将目前工作丢到背景中暂停</li>\n<li><code class=\"language-text\">jobs</code> 观察目前背景中工作状态</li>\n<li><code class=\"language-text\">fg %jobnumber</code> 将背景工作拿到前景来处理</li>\n<li><code class=\"language-text\">bg</code> 将背景中暂停的工作变成运行状态</li>\n<li><code class=\"language-text\">kill PID</code> 给某进程发送信号</li>\n<li><code class=\"language-text\">killall name</code> 给相关的所有进程发送信号</li>\n<li><code class=\"language-text\">nohup</code> 脱机管理工作</li>\n<li><code class=\"language-text\">nice/renice</code> 调整优先级</li>\n</ul>\n<p><code class=\"language-text\">kill/killall</code> 讯号signal：</p>\n<ul>\n<li><code class=\"language-text\">-9</code> 强制删除一个工作</li>\n<li><code class=\"language-text\">-15</code> 正常步骤结束一个工作（默认）</li>\n</ul>\n<h3>进程观察</h3>\n<p><code class=\"language-text\">ps</code> 将某个时间点的进程显示出来</p>\n<ul>\n<li><code class=\"language-text\">ps -l</code> 当前<code class=\"language-text\">bash</code> 的进程</li>\n<li><code class=\"language-text\">ps aux</code> 所有系统运作的进程</li>\n</ul>\n<p><code class=\"language-text\">top</code> 动态观察进程的状态，执行过程中可以使用指令：</p>\n<ul>\n<li>P 以CPU 使用资源排序</li>\n<li>M 以Memory 使用资源排序</li>\n<li>N 以PID 排序</li>\n<li>k 给予某个PID 一个signal</li>\n</ul>\n<p><code class=\"language-text\">pstree</code> 列出进程树，<code class=\"language-text\">-p</code> 同时列出PID</p>\n<h3>系统资源的观察</h3>\n<ul>\n<li><code class=\"language-text\">free</code> 观察内存使用情况</li>\n<li><code class=\"language-text\">uname</code> 查阅系统与核心相关信息</li>\n<li><code class=\"language-text\">uptime</code> 观察系统启动时间与工作负载</li>\n<li><code class=\"language-text\">netstat</code> 追踪网络或插槽文件</li>\n<li><code class=\"language-text\">dmesg</code> 分析核心产生的讯息</li>\n<li><code class=\"language-text\">vmstat</code> 侦测系统资源变化</li>\n</ul>\n<p><code class=\"language-text\">netstat</code> 参数</p>\n<ul>\n<li><code class=\"language-text\">-a</code> 将目前系统上所有的联机、监听、Socket 数据都列出来</li>\n<li><code class=\"language-text\">-t</code> 列出tcp 网络封包的数据</li>\n<li><code class=\"language-text\">-u</code> 列出udp 网络封包的数据</li>\n<li><code class=\"language-text\">-n</code> 不以进程的服务名称，以端口号来显示</li>\n<li><code class=\"language-text\">-l</code> 列出目前正在网络监听的服务（listing）</li>\n<li><code class=\"language-text\">-p</code> 列出改网络服务的进程PID</li>\n</ul>\n<p>常用命令<code class=\"language-text\">netstat -tulnp</code></p>\n<h2>系统服务 daemon</h2>\n<p>早起所有的服务启动脚本通通放置于<code class=\"language-text\">/etc/init.d/</code> 底下，现在用<code class=\"language-text\">systemd</code> 来进行管理。</p>\n<p><code class=\"language-text\">systemd</code> 配置文件放置目录：</p>\n<ul>\n<li><code class=\"language-text\">/usr/lib/systemd/system/</code></li>\n<li><code class=\"language-text\">/run/systemd/system/</code></li>\n<li><code class=\"language-text\">/etc/systemd/system/</code></li>\n</ul>\n<p>通过<code class=\"language-text\">systemctl</code> 指令管理</p>\n<p><code class=\"language-text\">systemctl [command] [unit]</code></p>\n<ul>\n<li>start</li>\n<li>stop</li>\n<li>restart</li>\n<li>reload 重载配置文件</li>\n<li>enable 下次开机时启动</li>\n<li>disable 下次开机时不启动</li>\n<li>status 状态</li>\n</ul>\n<p>直接<code class=\"language-text\">systemctl</code> 列出系统上启动的<code class=\"language-text\">unit</code></p>\n<h2>软件安装</h2>\n<h3>通过源码安装</h3>\n<p>一般步骤为：通过<code class=\"language-text\">configure</code> 来建立<code class=\"language-text\">Makefile</code>，之后通过<code class=\"language-text\">make</code> 安装即可。</p>\n<p><code class=\"language-text\">Makefile</code> 示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main:\n\tps aux &gt;&gt; 1.txt\nclean:\n\trm 1.txt</code></pre></div>\n<h3>软件安装</h3>\n<p>Red Hat/Fedora, RPM, rpm, yum</p>\n<p>Debian/Ubuntu, DPKG, dpkg, apt-get</p>","frontmatter":{"title":"Linux 知识点","date":"March 19, 2018","description":""}}},"pageContext":{"slug":"/20180320-knowledge-of-linux/","previous":{"fields":{"slug":"/20180308-way-to-config-ssh-key-login/","path":"/post/20180308-way-to-config-ssh-key-login/"},"frontmatter":{"title":"服务器设置SSH 通过密钥登录"}},"next":{"fields":{"slug":"/20180326-commands-of-git-remote/","path":"/post/20180326-commands-of-git-remote/"},"frontmatter":{"title":"Git 远程仓库相关的命令"}}}}}