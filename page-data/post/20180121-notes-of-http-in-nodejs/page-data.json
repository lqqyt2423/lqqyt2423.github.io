{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/20180121-notes-of-http-in-nodejs/","result":{"data":{"site":{"siteMetadata":{"title":"lqqyt2423's blog"}},"markdownRemark":{"id":"ff330b9f-eebb-5417-9119-9409b3ca6fa0","excerpt":"http.Server 类 要创建一个http 服务器，调用 方法，返回一个新建的 实例。  是一个函数，会自动被添加至事件。即每次服务器收到新的请求，都会调用此函数。 创建一个简单的服务端如下：  为开启HTTP…","html":"<h2>http.Server 类</h2>\n<p>要创建一个http 服务器，调用<code class=\"language-text\">http.createServer([requestListener])</code> 方法，返回一个新建的<code class=\"language-text\">http.Server</code> 实例。</p>\n<p><code class=\"language-text\">requestListener</code> 是一个函数，会自动被添加至<code class=\"language-text\">request</code>事件。即每次服务器收到新的请求，都会调用此函数。</p>\n<p>创建一个简单的服务端如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ok'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">server.listen()</code> 为开启HTTP 服务器的监听。常用的参数为<code class=\"language-text\">server.listen([port][, host][, backlog][, callback])</code>。<code class=\"language-text\">backlog</code> 指定待连接队列的最大长度。<code class=\"language-text\">callback</code> 即回调函数。</p>\n<p><code class=\"language-text\">server.listening</code> 返回一个布尔值，表示服务器是否正在监听连接。</p>\n<p>当服务端每接收到一个请求时，便会触发<code class=\"language-text\">request</code> 事件。一般即为调用<code class=\"language-text\">http.createServer()</code> 中传入的<code class=\"language-text\">requestListener</code> 函数。</p>\n<h2>http.IncomingMessage 类</h2>\n<p><code class=\"language-text\">requestListener</code> 函数会被传入两个参数，第一个即为<code class=\"language-text\">IncomingMessage</code> 对象，可用来访问响应状态、消息头和数据等。</p>\n<p><code class=\"language-text\">message.headers</code> 属性返回请求头的对象。此对象已经被处理过，为头信息的名称与值的键值对，且头信息的名称为小写。而接收到的原始请求会存放在<code class=\"language-text\">message.rawHeaders</code> 属性中，是<code class=\"language-text\">[key, value, key2, value2, ...]</code> 的数组，注意是数组，头信息的名称也不会被转换为小写，重复的头信息也不会被合并。</p>\n<p><code class=\"language-text\">message.httpVersion</code> 返回客户端发送的HTTP 版本。</p>\n<p><code class=\"language-text\">message.method</code> 返回一个字符串表示请求的方法，例如：<code class=\"language-text\">GET</code>, <code class=\"language-text\">POST</code>。</p>\n<p><code class=\"language-text\">message.url</code> 返回请求的URL 字符串。注意仅包含HTTP 请求中的URL，即不包含域名等信息。解析时可使用<code class=\"language-text\">require(&#39;url&#39;).parse(message.url, true)</code>，第二个可选参数<code class=\"language-text\">true</code> 表示从URL 查询字符串中提取参数，相当于<code class=\"language-text\">require(&#39;querystring&#39;).parse</code>。</p>\n<h2>http.ServerResponse 类</h2>\n<p>该对象在HTTP 服务器内部被创建，作为第二个参数传入<code class=\"language-text\">request</code> 事件。</p>\n<p><code class=\"language-text\">response.writeHead(statusCode[, statusMessage][, headers])</code> 可显式地发送一个响应头给请求。该方法只能在一个请求中调用一次，且需在<code class=\"language-text\">response.write()</code> 与<code class=\"language-text\">response.end()</code> 之前调用。</p>\n<p>也可隐式地发送HTTP 头部信息，通过设置<code class=\"language-text\">response.statusCode</code> 属性设置状态码， 通过<code class=\"language-text\">response.setHeader(name, value)</code> 设置响应头。注意如果<code class=\"language-text\">setHeader()</code> 与<code class=\"language-text\">writeHead()</code> 同时存在，则合并响应头，且<code class=\"language-text\">writeHead()</code> 具有较高优先级。</p>\n<blockquote>\n<p>头部信息<code class=\"language-text\">Content-Length</code> 是以字节为单位的，可使用<code class=\"language-text\">Buffer.byteLength()</code> 来确定字节长度。</p>\n</blockquote>\n<p><code class=\"language-text\">response.write(chunk[, encoding][, callback])</code> 此方法会发送一块响应主体，可被多次调用。</p>\n<p><code class=\"language-text\">response.end([data][, encoding][, callback])</code> 表示所有响应头与响应主体已全部发送完毕，每次响应必须包含此方法。之后便会触发<code class=\"language-text\">finish</code> 事件。</p>","frontmatter":{"title":"Node笔记之HTTP Server","date":"January 20, 2018","description":""}}},"pageContext":{"slug":"/20180121-notes-of-http-in-nodejs/","previous":{"fields":{"slug":"/20171230-way-to-check-type-in-javascript/","path":"/post/20171230-way-to-check-type-in-javascript/"},"frontmatter":{"title":"检测JavaScript 中各种类型"}},"next":{"fields":{"slug":"/20180220-achieve-simple-http-server-by-nodejs/","path":"/post/20180220-achieve-simple-http-server-by-nodejs/"},"frontmatter":{"title":"Node 实现简单HTTP 代理服务器"}}}}}