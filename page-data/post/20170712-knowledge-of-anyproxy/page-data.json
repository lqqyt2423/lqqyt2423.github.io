{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/20170712-knowledge-of-anyproxy/","result":{"data":{"site":{"siteMetadata":{"title":"lqqyt2423's blog"}},"markdownRemark":{"id":"b695f9f9-7c64-51ef-8242-b7d73ca67306","excerpt":"终端输入以下命令可以启用AnyProxy ， 参数的意思时启用HTTPS 传输模式 HTTP…","html":"<p>终端输入以下命令可以启用AnyProxy ，<code class=\"language-text\">-i</code> 参数的意思时启用HTTPS 传输模式</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sudo anyproxy -i</code></pre></div>\n<p>HTTP 通信过程的各个阶段进行抽离，分解成三个阶段：</p>\n<ul>\n<li>收到来自客户端请求之后，允许开发者直接从本地提供返回</li>\n<li>在转发请求到服务器前，允许开发者对发送的请求进行修改</li>\n<li>在收到服务器响应之后，允许开发者对响应内容进行修改，再返回给客户端</li>\n</ul>\n<p>对于上述每个阶段，AnyProxy 都提供了API接口，引入开发者编写自己的规则代码，实时干预通信过程，以此满足各类自定义需求。</p>\n<p>具体提供的接口包括：</p>\n<ul>\n<li>\n<p>收到用户请求之后</p>\n<ul>\n<li><strong>shouldUseLocalResponse</strong> ，是否在本地直接发送响应（不再向服务器发出请求）</li>\n<li><strong>dealLocalResponse</strong> 如果shouldUseLocalResponse 返回true，会调用这个函数来获取本地响应内容（异步接口）</li>\n</ul>\n</li>\n<li>\n<p>向服务端发出请求之前</p>\n<ul>\n<li><strong>replaceRequestProtocol</strong> 替换向服务器发出的请求协议，支持http和https的替换</li>\n<li><strong>replaceRequestOption</strong> 替换向服务器发出的请求参数，即nodeJS中的 <a href=\"http://nodejs.org/api/http.html#http_http_request_options_callback\">request option</a></li>\n<li><strong>replaceRequestData</strong> 替换请求的body</li>\n</ul>\n</li>\n<li>\n<p>向用户返回服务端的响应之前</p>\n<ul>\n<li><strong>replaceResponseStatusCode</strong> 替换服务器响应的http状态码</li>\n<li><strong>replaceResponseHeader</strong> 替换服务器响应的http头</li>\n<li><strong>replaceServerResDataAsync</strong> 替换服务器响应的数据（异步接口）</li>\n<li><strong>pauseBeforeSendingResponse</strong> 在请求返回给用户前的延迟时间</li>\n</ul>\n</li>\n</ul>\n<p>可以通过查看<code class=\"language-text\">/usr/local/lib/node_modules/anyproxy/rule_sample</code> 熟悉对应的规则。</p>\n<!-- more -->\n<p>解析HTTPS</p>\n<p>AnyProxy解析HTTPS的原理是自制根证书（rootCA），待终端信任这份证书之后，再用它签发各个域名的二级证书，此时二级证书可以重新对各个页面进行解析。这种方案和HTTPS的“中间人攻击”（MITM）是一致的。</p>\n<p>所以此证书是需要先安装的。安装参考：<a href=\"http://anyproxy.io/cn.html#osx%E7%B3%BB%E7%BB%9F%E4%BF%A1%E4%BB%BBca%E8%AF%81%E4%B9%A6\">http://anyproxy.io/cn.html#osx系统信任ca证书</a></p>\n<p>更多参考网址：</p>\n<ul>\n<li><a href=\"https://github.com/alibaba/anyproxy\">https://github.com/alibaba/anyproxy</a></li>\n<li><a href=\"https://github.com/alibaba/anyproxy/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%B0%E8%BD%AE%E5%AD%90%EF%BC%9Aanyproxy\">https://github.com/alibaba/anyproxy/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%B0%E8%BD%AE%E5%AD%90%EF%BC%9Aanyproxy</a></li>\n<li><a href=\"https://github.com/alibaba/anyproxy/wiki/HTTPS%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B\">https://github.com/alibaba/anyproxy/wiki/HTTPS%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B</a></li>\n<li><a href=\"https://github.com/alibaba/anyproxy/wiki/What-is-rule-file-and-how-to-write-one\">https://github.com/alibaba/anyproxy/wiki/What-is-rule-file-and-how-to-write-one</a></li>\n<li><a href=\"https://github.com/alibaba/anyproxy/issues/20\">https://github.com/alibaba/anyproxy/issues/20</a></li>\n</ul>\n<h2>微信查看历史消息程序中的知识点总结</h2>\n<h3>判断一些网页请求</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 通过Request头部accept判断请求的文件类型是否为图片</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token regex\">/image/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">.</span>accept<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 返回本地图片</span>\n  <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'content-type'</span><span class=\"token operator\">:</span> <span class=\"token string\">'image/png'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/Users/liqiang/Desktop/1.png'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 判断url时</span>\n<span class=\"token operator\">/</span>profile_ext<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 历史消息页</span>\n<span class=\"token operator\">/</span>getappmsgext<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 阅读量和点赞量的url</span></code></pre></div>\n<h3>rule_default.js</h3>\n<p>在<code class=\"language-text\">shouldUseLocalResponse</code> 这个接口中编写拦截代码，只让属于微信的<code class=\"language-text\">Request</code>请求通过，屏蔽其他网页和图片请求。具体代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 屏蔽除微信外其他网络连接</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token regex\">/[weixin|wx].qq.com/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">.</span>host<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// 历史消息抓取完成之后由发出的Ajax请求</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'/startAnother'</span> <span class=\"token operator\">==</span> req<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在<code class=\"language-text\">dealLocalResponse</code> 中不做任何反应，这样来自客户端的请求就不会无限发出了。当然需要对之后发出的Ajax 请求作出回应：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url <span class=\"token operator\">==</span> <span class=\"token string\">'/startAnother'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// 调用打印PDF的程序接口</span>\n    myRule<span class=\"token punctuation\">.</span><span class=\"token function\">toPdf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"content-type\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"text/plain\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>通过上面的两个接口，就可以只让微信的请求真正的发出去。然后接收到的响应数据便可以通过<code class=\"language-text\">replaceServerResDataAsync</code> 此接口来提取历史文章链接，以及注入返回至微信客户端的自动翻页js 代码。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function-variable function\">replaceServerResDataAsync</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span>res<span class=\"token punctuation\">,</span>serverResData<span class=\"token punctuation\">,</span>callback</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// 历史消息页判断，调用自己写的规则</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token regex\">/profile_ext.+__biz/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        myRule<span class=\"token punctuation\">.</span><span class=\"token function\">getProfile</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span>res<span class=\"token punctuation\">,</span>serverResData<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>serverResData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>此时便引用到了<code class=\"language-text\">myRule</code> 此模块文件了。前提是需要在开头通过<code class=\"language-text\">require</code>来引用：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> myRule <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./myRule'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>myRule.js</h3>\n<p>此文件中导出了两个方法，可以在上面文件引用：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exports<span class=\"token punctuation\">.</span>getProfile <span class=\"token operator\">=</span> getProfile<span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>toPdf <span class=\"token operator\">=</span> toPdf<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">getProfile</code>方法即通过分析<code class=\"language-text\">Response</code>数据，提取历史文章的链接，然后保存在文本文件中。具体细节部分：</p>\n<ul>\n<li>判断Response 为json 还是html ，然后根据对应的文件提取目标数据</li>\n<li>第一次返回的html 文件提取完目标之后，还需要注入一段js 代码，实现自动翻页功能和加载全部完成后发出Ajax 请求的功能</li>\n<li>发出Ajax 的请求便会依次通过<code class=\"language-text\">shouldUseLocalResponse</code>接口和<code class=\"language-text\">dealLocalResponse</code>接口，继而调用下面的<code class=\"language-text\">toPdf</code>方法</li>\n</ul>\n<p><code class=\"language-text\">toPdf</code>方法是提取完成后，发出调用直接爬虫的程序请求。</p>","frontmatter":{"title":"AnyProxy 知识点","date":"July 11, 2017","description":""}}},"pageContext":{"slug":"/20170712-knowledge-of-anyproxy/","previous":{"fields":{"slug":"/20170712-summary-of-basic-nodejs-knowledge/","path":"/post/20170712-summary-of-basic-nodejs-knowledge/"},"frontmatter":{"title":"Node 基础知识点总结"}},"next":{"fields":{"slug":"/20170726-usage-of-git-diff/","path":"/post/20170726-usage-of-git-diff/"},"frontmatter":{"title":"git diff 比较不同版本的差异"}}}}}